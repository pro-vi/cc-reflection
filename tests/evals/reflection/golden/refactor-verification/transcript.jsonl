{"type":"file-history-snapshot"}
{"type":"user","message":{"role":"user","content":"Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."}}
{"type":"user","message":{"role":"user","content":"<command-name>/clear</command-name>\n            <command-message>clear</command-message>\n            <command-args></command-args>"}}
{"type":"user","message":{"role":"user","content":"<local-command-stdout></local-command-stdout>"}}
{"type":"file-history-snapshot"}
{"type":"user","message":{"role":"user","content":"# Refactor Verification: Precondition Failure Case Tables\n\n## Context\n\nDuring a PROJ-123 refactoring session, an unsafe refactor was caught when the user asked: **\"how do you verify that the after and before is the same?\"**\n\nThe proposed refactor was to replace manual selection creation with the existing `$restoreSelection()` utility. At first glance, both approaches appeared equivalent—they both set anchor and focus positions. But investigation revealed a critical behavioral divergence on edge cases.\n\n### The Code in Question\n\n**Original code** (`EditorPlugin.svelte:839-843`):\n```typescript\nconst sel = lexicalCreateRangeSelection();  // CREATES new selection\nsel.anchor.set(captured.anchorKey, captured.anchorOffset, captured.anchorType);\nsel.focus.set(captured.focusKey, captured.focusOffset, captured.focusType);\nlexicalSetSelection(sel);\nsel.insertText(resultText);\n```\n\n**$restoreSelection utility** (`stream-utils.ts:166-183`):\n```typescript\nconst selection = $getSelection();  // RETRIEVES existing selection\nif (!$isRangeSelection(selection)) {\n  return false;  // Early return if no selection or wrong type\n}\nselection.anchor.set(range.anchorKey, range.anchorOffset, range.anchorType);\nselection.focus.set(range.focusKey, range.focusOffset, range.focusType);\nreturn true;\n```\n\n---\n\n## The Hidden Divergence\n\nThe verification method that caught this:\n\n### 1. Trace Both Paths Step-by-Step\n\n| Step | Original | $restoreSelection |\n|------|----------|-------------------|\n| 1 | Call `$createRangeSelection()` | Call `$getSelection()` |\n| 2 | Always returns new RangeSelection | Returns null, NodeSelection, RangeSelection, or GridSelection |\n| 3 | Set anchor/focus on new selection | Type guard check |\n| 4 | Call `$setSelection(sel)` | If wrong type → return false |\n| 5 | — | If correct type → mutate existing |\n\n### 2. Build Case Table for Preconditions\n\n| Precondition | Original | $restoreSelection |\n|--------------|----------|-------------------|\n| Valid RangeSelection exists | ✓ Works | ✓ Works |\n| No selection (null) | ✓ Creates new selection | ✗ Returns false |\n| NodeSelection exists | ✓ Creates new RangeSelection | ✗ Returns false |\n| GridSelection exists | ✓ Creates new RangeSelection | ✗ Returns false |\n| Selection nodes are stale | ⚠️ May position incorrectly | ⚠️ May position incorrectly |\n\n### 3. Identify the Semantic Difference\n\n- **`$createRangeSelection()`** is **generative** — always produces output\n- **`$getSelection()`** is **retrieval** — depends on editor state\n\nThe refactor conflated two fundamentally different operations that happened to share the same \"set anchor/focus\" syntax.\n\n---\n\n## Recommended Addition to Refactor Skill\n\nAdd a **\"Behavioral Equivalence Verification\"** section after \"Phase 2: Plan\" or integrate into \"Risks to Avoid\":\n\n### Verification Checklist: Before ≡ After\n\nWhen replacing code A with code B:\n\n1. **Trace preconditions**\n   - What state must exist for A to work? For B?\n   - Is A generative (creates state) or retrieval (reads state)?\n   - Is B generative or retrieval?\n\n2. **Build a case table**\n   | Precondition | A's Behavior | B's Behavior |\n   |--------------|--------------|--------------|\n   | Happy path | ? | ? |\n   | Null/undefined | ? | ? |\n   | Wrong type | ? | ? |\n   | Stale reference | ? | ? |\n\n3. **Ask \"what if the precondition fails?\"**\n   - Original creates fallback → refactor must too\n   - Original throws → refactor must match error contract\n   - Original no-ops → refactor must match silent behavior\n\n4. **Check return value semantics**\n   - Does original return void vs value?\n   - Does the utility return status (boolean) vs result?\n   - Does caller check the return?\n\n### Anti-Pattern: \"Same Signature\" Trap\n\nTwo functions with identical parameters and similar names may have inverted semantics:\n- `createX()` vs `getX()` — generative vs retrieval\n- `ensureX()` vs `requireX()` — creates-if-missing vs throws-if-missing\n- `setX(val)` vs `updateX(val)` — replace vs merge\n\n**Rule:** When refactoring to a utility, verify the utility's behavior on ALL input states, not just the happy path the original code happened to handle.\n\n---\n\n## Implementation Options\n\n### Option A: Add to Refactor Skill (Recommended)\n\nLocation: `~/.claude/skills/refactor/skill.md`\n\nAdd under \"Risks to Avoid\" as a new section:\n\n```markdown\n## Behavioral Equivalence Verification\n\nBefore replacing code with a utility:\n\n1. **Trace preconditions** - Is original generative (creates) or retrieval (reads)?\n2. **Case table** - What happens when: null, wrong type, stale reference?\n3. **Return semantics** - Does caller handle the utility's return contract?\n\nAnti-pattern: \"Same Signature\" trap - `createX()` vs `getX()` look similar but have inverted semantics.\n```\n\n### Option B: Add to CLAUDE.md Technical Decisions\n\nCould add as a meta-pattern under Technical Decisions, but this feels more like a workflow pattern than a project-specific decision. The refactor skill is the better home.\n\n---\n\n## Success Criteria\n\n- Refactor skill includes case-table verification step\n- Pattern catches \"generative vs retrieval\" semantic mismatches\n- Checklist is actionable (can be applied mechanically)\n\n---\n\n## Investigation Notes\n\n**Evidence gathered:**\n- `stream-utils.ts:166-183` — `$restoreSelection` implementation confirms retrieval pattern\n- `EditorPlugin.svelte:839-843` — Original code uses generative pattern\n- `stream-utils.test.ts:305-416` — Tests for `$restoreSelection` confirm false-return behavior\n- Git history shows PROJ-123 introduced the streaming primitives layer\n\n**Files affected by this pattern (similar generative/retrieval pairs in codebase):**\n- `agent-utils.ts:194` — Uses `$createRangeSelection()` (generative)\n- `block-transformers.test.ts` — Multiple instances of manual selection creation\n\nThe pattern is particularly relevant to Lexical development where `$create*` and `$get*` functions have inverted semantics but similar call patterns."}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"thinking"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"I'll read the current refactor skill to understand its structure and find the best placement for this addition."}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"tool_use","name":"Read","input":{"file_path":"/home/user/.claude/skills/refactor/skill.md"},"id":"toolu_01SnfZu5AUgLvAUD4jh2J6oW"}]}}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_01SnfZu5AUgLvAUD4jh2J6oW","content":"     1→---\n     2→name: refactor\n     3→description: \"Systematic code refactoring without changing behavior. Invoke on: 'refactor', 'clean up', 'extract', 'rename', 'move', 'DRY', 'dedupe', 'simplify', 'flatten', 'improve readability'. Do NOT use for: formatting-only, performance tuning, dependency upgrades, framework migrations, or feature rewrites.\"\n     4→---\n     5→\n     6→# Refactor Skill\n     7→\n     8→**Purpose:** Improve code structure, readability, and maintainability without changing external behavior.\n     9→\n    10→---\n    11→\n    12→## Core Principles\n    13→\n    14→- **Tests First** - All refactoring must be covered by tests. Write them first if missing.\n    15→- **Preserve Behavior** - Never add features or change logic during refactoring. Separate PRs.\n    16→- **Small Steps** - One atomic change, verify, repeat.\n    17→- **Names Matter** - Better naming is often the highest-value refactor.\n    18→- **Avoid Premature Abstraction** - Extract only when pattern repeats 2+ times.\n    19→\n    20→---\n    21→\n    22→## Workflow\n    23→\n    24→### Phase 1: Analyze\n    25→\n    26→1. Understand code's purpose (inputs/outputs)\n    27→2. Identify the smell (duplication, long function, complex conditionals, poor naming)\n    28→3. **Check test coverage** - If weak, state that writing characterization tests is the first step\n    29→4. Determine scope (single function vs multiple files vs architectural)\n    30→\n    31→### Phase 2: Plan\n    32→\n    33→1. Propose specific changes with rationale\n    34→2. **Map blast radius** - Ask user about downstream consumers you can't see\n    35→3. Risk assessment - What could break? How to verify?\n    36→4. For public APIs: consider semver implications\n    37→\n    38→### Phase 3: Execute\n    39→\n    40→1. If tests missing: write characterization tests first\n    41→2. Make ONE small change\n    42→3. Verify tests pass\n    43→4. Repeat\n    44→5. Use code-aware tools for renames (LSP/tsserver, not manual search-replace)\n    45→\n    46→### Phase 4: Verify\n    47→\n    48→1. Run project's test script\n    49→2. Run project's type check\n    50→3. Run linter\n    51→4. Review diff for unintended changes\n    52→5. Confirm behavior unchanged\n    53→\n    54→---\n    55→\n    56→## Refactoring Patterns\n    57→\n    58→**Extract Function** - Code block does one logical thing, or appears 2+ times\n    59→\n    60→**Extract Constant** - Magic numbers/strings lacking context\n    61→\n    62→**Rename Symbol** - Improve clarity with descriptive name (use LSP-aware tools)\n    63→\n    64→**Inline Function** - Remove abstraction that adds more confusion than value\n    65→\n    66→**Introduce Explaining Variable** - Replace complex expression with well-named intermediate\n    67→\n    68→**Move Module/Method** - Relocate to better home (preserve imports/exports)\n    69→\n    70→**Guard Clauses** - Replace deep nesting with early returns\n    71→\n    72→**Consolidate Duplicate (DRY)** - Abstract repeated logic to shared function\n    73→\n    74→**Remove Dead Code** - Delete unused branches, flags, feature toggles\n    75→\n    76→**(Advanced) Replace Conditional with Polymorphism** - When switch/if-chain varies behavior by type\n    77→\n    78→---\n    79→\n    80→## Type Safety Refactoring\n    81→\n    82→**Eliminate Unsafe Casts** - Replace with type guards or discriminated unions\n    83→\n    84→**Create Test Factories** - DRY verbose object construction in tests\n    85→\n    86→Note: For proactive type safety (before writing casts), use the `casting` skill.\n    87→\n    88→---\n    89→\n    90→## Risks to Avoid\n    91→\n    92→- **Mixing refactor with features** - Separate PRs. Don't \"fix bugs while here.\"\n    93→- **Big-bang renames** - Use code-aware tools. Keep changes scoped.\n    94→- **Breaking public APIs** - Respect semver. Add deprecations and migration paths.\n    95→- **Async reordering** - Can change timing, event emission, lock acquisition. Verify with async tests.\n    96→- **Manual search-replace** - Dangerous for renames. Use LSP/tsserver.\n    97→- **Removing \"unused\" code** - May be used dynamically. Check callers thoroughly.\n    98→\n    99→---\n   100→\n   101→## Reuse Strategy\n   102→\n   103→Before creating utilities, search for existing ones:\n   104→```bash\n   105→grep -r \"function is[A-Z]\" --include=\"*.ts\" src/     # Type guards\n   106→grep -r \"function create[A-Z]\" --include=\"*.test.ts\" # Test factories\n   107→```\n   108→\n   109→Priority: Import existing → Extend existing → Create new (with extraction hint)\n   110→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"thinking"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"The refactor skill is well-structured. The new \"Behavioral Equivalence Verification\" section fits naturally between \"Risks to Avoid\" and \"Reuse Strategy\" since it:\n1. Addresses a specific risk category (semantic divergence)\n2. Is particularly relevant when reusing utilities\n\nLet me write the plan."}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"tool_use","name":"Write","input":{"file_path":"/home/user/.claude/plans/cached-forging-charm.md","content":"# Plan: Add Behavioral Equivalence Verification to Refactor Skill\n\n## Summary\n\nAdd a new section to `~/.claude/skills/refactor/skill.md` that provides a systematic checklist for verifying that refactored code preserves behavior on ALL input states, not just the happy path.\n\n## Placement\n\nInsert between \"Risks to Avoid\" (line 90-97) and \"Reuse Strategy\" (line 101) since:\n- It addresses a specific risk category (generative vs retrieval semantic mismatch)\n- It's most relevant when considering utility reuse\n\n## Content to Add\n\n```markdown\n---\n\n## Behavioral Equivalence Verification\n\nWhen replacing code A with utility B, verify behavior matches on ALL states:\n\n### Checklist\n\n1. **Trace preconditions**\n   - What state must exist for A to work? For B?\n   - Is A generative (`create*`, `ensure*`) or retrieval (`get*`, `find*`)?\n   - Is B generative or retrieval?\n\n2. **Build case table**\n   | Precondition | A's Behavior | B's Behavior |\n   |--------------|--------------|--------------|\n   | Happy path   |              |              |\n   | Null/undefined |            |              |\n   | Wrong type   |              |              |\n   | Stale reference |           |              |\n\n3. **Failure behavior**\n   - Original creates fallback → refactor must too\n   - Original throws → refactor must match error contract\n   - Original no-ops → refactor must match silent behavior\n\n4. **Return semantics**\n   - Does original return void vs value?\n   - Does utility return status (boolean) vs result?\n   - Does caller check the return?\n\n### Anti-Pattern: \"Same Signature\" Trap\n\nFunctions with identical parameters may have inverted semantics:\n- `createX()` vs `getX()` — generative vs retrieval\n- `ensureX()` vs `requireX()` — creates-if-missing vs throws-if-missing\n- `setX(val)` vs `updateX(val)` — replace vs merge\n\n**Rule:** Verify utility behavior on ALL input states, not just the happy path.\n```\n\n## Implementation\n\nSingle edit to `~/.claude/skills/refactor/skill.md`:\n- Insert after line 97 (end of \"Risks to Avoid\")\n- Before line 99 (start of \"Reuse Strategy\")\n\n## Validation\n\n- Read the modified file to confirm proper formatting\n- Verify markdown renders correctly (headers, table, code blocks)\n"},"id":"toolu_01FDhnQXnxmcpJj13utNJjfp"}]}}
{"type":"file-history-snapshot"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_01FDhnQXnxmcpJj13utNJjfp","content":"File created successfully at: /home/user/.claude/plans/cached-forging-charm.md"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"thinking"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"This is a straightforward addition. The plan:\n\n1. **Single file edit** - `~/.claude/skills/refactor/skill.md`\n2. **New section** - \"Behavioral Equivalence Verification\" inserted between \"Risks to Avoid\" and \"Reuse Strategy\"\n3. **Content** - Condensed checklist from your document (preconditions, case table, failure behavior, return semantics) plus the \"Same Signature\" anti-pattern\n\nThe content follows the skill's existing style (terse, actionable checklists)."}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"tool_use","name":"ExitPlanMode","input":{"plan":"# Plan: Add Behavioral Equivalence Verification to Refactor Skill\n\n## Summary\n\nAdd a new section to `~/.claude/skills/refactor/skill.md` that provides a systematic checklist for verifying that refactored code preserves behavior on ALL input states, not just the happy path.\n\n## Placement\n\nInsert between \"Risks to Avoid\" (line 90-97) and \"Reuse Strategy\" (line 101) since:\n- It addresses a specific risk category (generative vs retrieval semantic mismatch)\n- It's most relevant when considering utility reuse\n\n## Content to Add\n\n```markdown\n---\n\n## Behavioral Equivalence Verification\n\nWhen replacing code A with utility B, verify behavior matches on ALL states:\n\n### Checklist\n\n1. **Trace preconditions**\n   - What state must exist for A to work? For B?\n   - Is A generative (`create*`, `ensure*`) or retrieval (`get*`, `find*`)?\n   - Is B generative or retrieval?\n\n2. **Build case table**\n   | Precondition | A's Behavior | B's Behavior |\n   |--------------|--------------|--------------|\n   | Happy path   |              |              |\n   | Null/undefined |            |              |\n   | Wrong type   |              |              |\n   | Stale reference |           |              |\n\n3. **Failure behavior**\n   - Original creates fallback → refactor must too\n   - Original throws → refactor must match error contract\n   - Original no-ops → refactor must match silent behavior\n\n4. **Return semantics**\n   - Does original return void vs value?\n   - Does utility return status (boolean) vs result?\n   - Does caller check the return?\n\n### Anti-Pattern: \"Same Signature\" Trap\n\nFunctions with identical parameters may have inverted semantics:\n- `createX()` vs `getX()` — generative vs retrieval\n- `ensureX()` vs `requireX()` — creates-if-missing vs throws-if-missing\n- `setX(val)` vs `updateX(val)` — replace vs merge\n\n**Rule:** Verify utility behavior on ALL input states, not just the happy path.\n```\n\n## Implementation\n\nSingle edit to `~/.claude/skills/refactor/skill.md`:\n- Insert after line 97 (end of \"Risks to Avoid\")\n- Before line 99 (start of \"Reuse Strategy\")\n\n## Validation\n\n- Read the modified file to confirm proper formatting\n- Verify markdown renders correctly (headers, table, code blocks)\n"},"id":"toolu_01KTS5XAWqcAHs4S1QTZJtTJ"}]}}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_01KTS5XAWqcAHs4S1QTZJtTJ","content":"User has approved your plan. You can now start coding. Start with updating your todo list if applicable\n\nYour plan has been saved to: /home/user/.claude/plans/cached-forging-charm.md\nYou can refer back to it if needed during implementation.\n\n## Approved Plan:\n# Plan: Add Behavioral Equivalence Verification to Refactor Skill\n\n## Summary\n\nAdd a new section to `~/.claude/skills/refactor/skill.md` that provides a systematic checklist for verifying that refactored code preserves behavior on ALL input states, not just the happy path.\n\n## Placement\n\nInsert between \"Risks to Avoid\" (line 90-97) and \"Reuse Strategy\" (line 101) since:\n- It addresses a specific risk category (generative vs retrieval semantic mismatch)\n- It's most relevant when considering utility reuse\n\n## Content to Add\n\n```markdown\n---\n\n## Behavioral Equivalence Verification\n\nWhen replacing code A with utility B, verify behavior matches on ALL states:\n\n### Checklist\n\n1. **Trace preconditions**\n   - What state must exist for A to work? For B?\n   - Is A generative (`create*`, `ensure*`) or retrieval (`get*`, `find*`)?\n   - Is B generative or retrieval?\n\n2. **Build case table**\n   | Precondition | A's Behavior | B's Behavior |\n   |--------------|--------------|--------------|\n   | Happy path   |              |              |\n   | Null/undefined |            |              |\n   | Wrong type   |              |              |\n   | Stale reference |           |              |\n\n3. **Failure behavior**\n   - Original creates fallback → refactor must too\n   - Original throws → refactor must match error contract\n   - Original no-ops → refactor must match silent behavior\n\n4. **Return semantics**\n   - Does original return void vs value?\n   - Does utility return status (boolean) vs result?\n   - Does caller check the return?\n\n### Anti-Pattern: \"Same Signature\" Trap\n\nFunctions with identical parameters may have inverted semantics:\n- `createX()` vs `getX()` — generative vs retrieval\n- `ensureX()` vs `requireX()` — creates-if-missing vs throws-if-missing\n- `setX(val)` vs `updateX(val)` — replace vs merge\n\n**Rule:** Verify utility behavior on ALL input states, not just the happy path.\n```\n\n## Implementation\n\nSingle edit to `~/.claude/skills/refactor/skill.md`:\n- Insert after line 97 (end of \"Risks to Avoid\")\n- Before line 99 (start of \"Reuse Strategy\")\n\n## Validation\n\n- Read the modified file to confirm proper formatting\n- Verify markdown renders correctly (headers, table, code blocks)\n"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"thinking"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"tool_use","name":"TodoWrite","input":{"todos":[{"content":"Add Behavioral Equivalence Verification section to refactor skill","status":"in_progress","activeForm":"Adding Behavioral Equivalence Verification section"}]},"id":"toolu_01Uqs11GkoSiEAUxDS8sxA8s"}]}}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_01Uqs11GkoSiEAUxDS8sxA8s","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"thinking"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"tool_use","name":"Edit","input":{"file_path":"/home/user/.claude/skills/refactor/skill.md","old_string":"- **Removing \"unused\" code** - May be used dynamically. Check callers thoroughly.\n\n---\n\n## Reuse Strategy","new_string":"- **Removing \"unused\" code** - May be used dynamically. Check callers thoroughly.\n\n---\n\n## Behavioral Equivalence Verification\n\nWhen replacing code A with utility B, verify behavior matches on ALL states:\n\n### Checklist\n\n1. **Trace preconditions**\n   - What state must exist for A to work? For B?\n   - Is A generative (`create*`, `ensure*`) or retrieval (`get*`, `find*`)?\n   - Is B generative or retrieval?\n\n2. **Build case table**\n   | Precondition | A's Behavior | B's Behavior |\n   |--------------|--------------|--------------|\n   | Happy path   |              |              |\n   | Null/undefined |            |              |\n   | Wrong type   |              |              |\n   | Stale reference |           |              |\n\n3. **Failure behavior**\n   - Original creates fallback → refactor must too\n   - Original throws → refactor must match error contract\n   - Original no-ops → refactor must match silent behavior\n\n4. **Return semantics**\n   - Does original return void vs value?\n   - Does utility return status (boolean) vs result?\n   - Does caller check the return?\n\n### Anti-Pattern: \"Same Signature\" Trap\n\nFunctions with identical parameters may have inverted semantics:\n- `createX()` vs `getX()` — generative vs retrieval\n- `ensureX()` vs `requireX()` — creates-if-missing vs throws-if-missing\n- `setX(val)` vs `updateX(val)` — replace vs merge\n\n**Rule:** Verify utility behavior on ALL input states, not just the happy path.\n\n---\n\n## Reuse Strategy"},"id":"toolu_01UTsUd9dG1PfcE6dSAfmPDn"}]}}
{"type":"file-history-snapshot"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_01UTsUd9dG1PfcE6dSAfmPDn","content":"The file /home/user/.claude/skills/refactor/skill.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    93→- **Big-bang renames** - Use code-aware tools. Keep changes scoped.\n    94→- **Breaking public APIs** - Respect semver. Add deprecations and migration paths.\n    95→- **Async reordering** - Can change timing, event emission, lock acquisition. Verify with async tests.\n    96→- **Manual search-replace** - Dangerous for renames. Use LSP/tsserver.\n    97→- **Removing \"unused\" code** - May be used dynamically. Check callers thoroughly.\n    98→\n    99→---\n   100→\n   101→## Behavioral Equivalence Verification\n   102→\n   103→When replacing code A with utility B, verify behavior matches on ALL states:\n   104→\n   105→### Checklist\n   106→\n   107→1. **Trace preconditions**\n   108→   - What state must exist for A to work? For B?\n   109→   - Is A generative (`create*`, `ensure*`) or retrieval (`get*`, `find*`)?\n   110→   - Is B generative or retrieval?\n   111→\n   112→2. **Build case table**\n   113→   | Precondition | A's Behavior | B's Behavior |\n   114→   |--------------|--------------|--------------|\n   115→   | Happy path   |              |              |\n   116→   | Null/undefined |            |              |\n   117→   | Wrong type   |              |              |\n   118→   | Stale reference |           |              |\n   119→\n   120→3. **Failure behavior**\n   121→   - Original creates fallback → refactor must too\n   122→   - Original throws → refactor must match error contract\n   123→   - Original no-ops → refactor must match silent behavior\n   124→\n   125→4. **Return semantics**\n   126→   - Does original return void vs value?\n   127→   - Does utility return status (boolean) vs result?\n   128→   - Does caller check the return?\n   129→\n   130→### Anti-Pattern: \"Same Signature\" Trap\n   131→\n   132→Functions with identical parameters may have inverted semantics:\n   133→- `createX()` vs `getX()` — generative vs retrieval\n   134→- `ensureX()` vs `requireX()` — creates-if-missing vs throws-if-missing\n   135→- `setX(val)` vs `updateX(val)` — replace vs merge\n   136→\n   137→**Rule:** Verify utility behavior on ALL input states, not just the happy path.\n   138→\n   139→---\n   140→\n   141→## Reuse Strategy\n   142→\n   143→Before creating utilities, search for existing ones:\n   144→```bash\n   145→grep -r \"function is[A-Z]\" --include=\"*.ts\" src/     # Type guards"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"thinking"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"tool_use","name":"TodoWrite","input":{"todos":[{"content":"Add Behavioral Equivalence Verification section to refactor skill","status":"completed","activeForm":"Adding Behavioral Equivalence Verification section"}]},"id":"toolu_01E9t1s786i2o8TkSxRqkSga"}]}}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_01E9t1s786i2o8TkSxRqkSga","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"thinking"}]}}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"Done. Added the **Behavioral Equivalence Verification** section to `~/.claude/skills/refactor/skill.md` (lines 101-137).\n\nThe section includes:\n- **Checklist** - 4-step verification (preconditions, case table, failure behavior, return semantics)\n- **Anti-Pattern** - \"Same Signature\" trap with `create*/get*`, `ensure*/require*`, `set*/update*` examples\n- **Rule** - Verify on ALL input states, not just happy path\n\nThis will catch future generative-vs-retrieval semantic mismatches like the `$createRangeSelection()` → `$restoreSelection()` case."}]}}
{"type":"system"}
